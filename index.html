<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>背景特效库演示项目</title>
    <meta name="description" content="展示多种流行的 JavaScript 背景特效库，包括 Anime.js、Canvas Confetti、Rough.js、Trianglify、Three.js、P5.js、Vanta.js、Particles.js 等">
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <!-- 页头区域 -->
        <header class="header">
            <h1>背景特效库演示项目</h1>
            <p class="subtitle">
                探索各种令人惊叹的 Web 背景特效库，每个库都提供了多种精美效果供您体验和学习。
                点击下方卡片进入对应的演示页面，切换不同的特效样式。
            </p>
        </header>

        <!-- 特效库卡片网格 -->
        <main class="cards-grid">
            <!-- Anime.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Anime.js 效果预览">
                    <canvas id="anime-preview"></canvas>
                </div>
                <h3 class="card-title">Anime.js</h3>
                <p class="card-description">
                    轻量级的 JavaScript 动画库，专注于 DOM 元素动画。提供丰富的动画效果，如文字动画、图形变换、路径绘制等。
                </p>
                <a href="libs/anime-js/index.html" class="btn btn-primary btn-full" aria-label="进入 Anime.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Canvas Confetti 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Canvas Confetti 效果预览">
                    <canvas id="confetti-preview"></canvas>
                </div>
                <h3 class="card-title">Canvas Confetti</h3>
                <p class="card-description">
                    专业的彩带庆祝效果库，轻量高效。提供爆炸、下雨、烟花等多种庆祝动画，完美适用于节庆和庆祝场景。
                </p>
                <a href="libs/canvas-confetti/index.html" class="btn btn-primary btn-full" aria-label="进入 Canvas Confetti 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Rough.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Rough.js 效果预览">
                    <canvas id="rough-preview"></canvas>
                </div>
                <h3 class="card-title">Rough.js</h3>
                <p class="card-description">
                    独特的手绘风格图形库，模拟真实手工绘制效果。支持各种几何图形，为网页添加自然粗糙的艺术感。
                </p>
                <a href="libs/rough-js/index.html" class="btn btn-primary btn-full" aria-label="进入 Rough.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Trianglify 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Trianglify 效果预览">
                    <canvas id="trianglify-preview"></canvas>
                </div>
                <h3 class="card-title">Trianglify</h3>
                <p class="card-description">
                    几何三角形背景生成器，可创建低多边形（Low Poly）风格的背景。支持自定义颜色、尺寸和密度。
                </p>
                <a href="libs/trianglify/index.html" class="btn btn-primary btn-full" aria-label="进入 Trianglify 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Canvas Nest 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Canvas Nest 效果预览">
                    <canvas id="canvas-nest-preview"></canvas>
                </div>
                <h3 class="card-title">Canvas Nest</h3>
                <p class="card-description">
                    创建连线粒子效果的轻量级库。粒子会随鼠标移动并相互连接，形成动态的网格背景效果。
                </p>
                <a href="libs/canvas-nest/index.html" class="btn btn-primary btn-full" aria-label="进入 Canvas Nest 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Matter.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Matter.js 效果预览">
                    <canvas id="matter-preview"></canvas>
                </div>
                <h3 class="card-title">Matter.js</h3>
                <p class="card-description">
                    2D 物理引擎，可创建具有重力、碰撞、约束等物理特性的背景效果。适合制作互动性强的动态背景。
                </p>
                <a href="libs/matter-js/index.html" class="btn btn-primary btn-full" aria-label="进入 Matter.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Three.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Three.js 效果预览">
                    <canvas id="three-preview"></canvas>
                </div>
                <h3 class="card-title">Three.js</h3>
                <p class="card-description">
                    功能最强大的 3D 图形库，可创建复杂的 3D 背景效果，如旋转的几何体、粒子系统、着色器效果等。
                </p>
                <a href="libs/three-js/index.html" class="btn btn-primary btn-full" aria-label="进入 Three.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- P5.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="P5.js 效果预览">
                    <canvas id="p5-preview"></canvas>
                </div>
                <h3 class="card-title">P5.js</h3>
                <p class="card-description">
                    创意编程库，适合制作艺术性和生成性的背景效果。提供简洁的 API，便于创建各种视觉艺术作品。
                </p>
                <a href="libs/p5-js/index.html" class="btn btn-primary btn-full" aria-label="进入 P5.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Vanta.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Vanta.js 效果预览">
                    <canvas id="vanta-preview"></canvas>
                </div>
                <h3 class="card-title">Vanta.js</h3>
                <p class="card-description">
                    基于 Three.js 的 3D 背景特效库，提供波浪、云朵、网格、鸟群等多种精美的 3D 背景效果。
                </p>
                <a href="libs/vanta/index.html" class="btn btn-primary btn-full" aria-label="进入 Vanta.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- Particles.js 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="Particles.js 效果预览">
                    <canvas id="particles-preview"></canvas>
                </div>
                <h3 class="card-title">Particles.js</h3>
                <p class="card-description">
                    经典的粒子背景库，轻量高效。提供连线粒子、雪花、气泡等多种粒子效果，兼容性极佳。
                </p>
                <a href="libs/particles/index.html" class="btn btn-primary btn-full" aria-label="进入 Particles.js 演示">
                    进入演示 →
                </a>
            </article>

            <!-- GSAP 卡片 -->
            <article class="card">
                <div class="card-preview" aria-label="GSAP 效果预览">
                    <canvas id="gsap-preview"></canvas>
                </div>
                <h3 class="card-title">GSAP</h3>
                <p class="card-description">
                    专业级动画库，功能强大且性能卓越。支持文字动画、位移变换、SVG动画、滚动触发等高级效果。
                </p>
                <a href="libs/gsap/index.html" class="btn btn-primary btn-full" aria-label="进入 GSAP 演示">
                    进入演示 →
                </a>
            </article>
        </main>

        <!-- 页脚 -->
        <footer class="footer">
            <p>&copy; 2024 背景特效库演示项目. 本项目仅供学习和演示使用.</p>
            <p>各特效库的版权归其原作者所有</p>
        </footer>
    </div>

    <script>
        // 简单的预览效果初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 为预览 canvas 添加简单的占位效果
            initPreviews();
        });

        function initPreviews() {
            const previews = document.querySelectorAll('.card-preview canvas');
            
            previews.forEach((canvas, index) => {
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                // 根据不同的库显示不同的预览效果
                switch(index) {
                    case 0: // Anime.js
                        drawAnimePreview(ctx, canvas.width, canvas.height);
                        break;
                    case 1: // Canvas Confetti
                        drawConfettiPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 2: // Rough.js
                        drawRoughPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 3: // Trianglify
                        drawTrianglesPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 4: // Canvas Nest
                        drawNetPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 5: // Matter.js
                        drawPhysicsPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 6: // Three.js
                        draw3DPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 7: // P5.js
                        drawGenerativePreview(ctx, canvas.width, canvas.height);
                        break;
                    case 8: // Vanta.js
                        drawVantaPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 9: // Particles.js
                        drawParticlesJSPreview(ctx, canvas.width, canvas.height);
                        break;
                    case 10: // GSAP
                        drawGSAPPreview(ctx, canvas.width, canvas.height);
                        break;
                }
            });
        }

        // 预览效果绘制函数
        function drawConfettiPreview(ctx, width, height) {
            // 创建模拟 Canvas Confetti 彩带效果的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.004;
            const confettiColors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7'];
            
            // 绘制彩带片（下落效果）
            for (let i = 0; i < 20; i++) {
                const x = (i * 50 + Math.sin(time + i) * 30) % (width + 100) - 50;
                const y = (time * 100 + i * 40) % (height + 100) - 50;
                const rotation = time + i * 0.5;
                const size = 8 + Math.sin(time * 2 + i) * 4;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = confettiColors[i % confettiColors.length];
                ctx.globalAlpha = 0.8;
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.restore();
            }
            
            // 添加一些圆形彩带
            for (let i = 0; i < 15; i++) {
                const x = ((i * 60 + Math.cos(time * 0.8 + i) * 40) % (width + 100)) - 50;
                const y = ((time * 80 + i * 50) % (height + 100)) - 50;
                const size = 6 + Math.sin(time * 3 + i * 0.7) * 3;
                
                ctx.fillStyle = confettiColors[(i + 3) % confettiColors.length];
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawRoughPreview(ctx, width, height) {
            // 创建模拟 Rough.js 手绘风格的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.002;
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.8;
            
            // 绘制不规则矩形（模拟手绘效果）
            for (let i = 0; i < 6; i++) {
                const x = (i % 3) * (width / 3) + width / 6;
                const y = Math.floor(i / 3) * (height / 2) + height / 4;
                const size = 40 + Math.sin(time + i) * 10;
                
                // 模拟手绘的不规则线条
                ctx.strokeStyle = ['#6366f1', '#8b5cf6', '#ec4899'][i % 3];
                ctx.beginPath();
                
                // 不规则的矩形
                const jitter = 3;
                ctx.moveTo(x - size/2 + Math.random() * jitter, y - size/2 + Math.random() * jitter);
                ctx.lineTo(x + size/2 + Math.random() * jitter, y - size/2 + Math.random() * jitter);
                ctx.lineTo(x + size/2 + Math.random() * jitter, y + size/2 + Math.random() * jitter);
                ctx.lineTo(x - size/2 + Math.random() * jitter, y + size/2 + Math.random() * jitter);
                ctx.closePath();
                ctx.stroke();
                
                // 添加手绘风格的填充线条
                if (i % 2 === 0) {
                    ctx.globalAlpha = 0.3;
                    for (let j = 0; j < 5; j++) {
                        const lineY = y - size/2 + (j / 4) * size + Math.sin(time * 2 + i + j) * 2;
                        ctx.beginPath();
                        ctx.moveTo(x - size/2, lineY);
                        ctx.lineTo(x + size/2, lineY);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 0.8;
                }
            }
            
            // 绘制一些手绘风格的圆形
            for (let i = 0; i < 4; i++) {
                const centerX = width / 2 + Math.cos(time + i * Math.PI / 2) * 60;
                const centerY = height / 2 + Math.sin(time + i * Math.PI / 2) * 40;
                const radius = 15 + Math.sin(time * 3 + i) * 5;
                
                ctx.strokeStyle = '#f59e0b';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                
                // 不规则的圆形路径
                const points = 16;
                for (let j = 0; j <= points; j++) {
                    const angle = (j / points) * Math.PI * 2;
                    const r = radius + Math.sin(angle * 4 + time * 2) * 3;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
        }
        
        function drawAnimePreview(ctx, width, height) {
            // 创建模拟 Anime.js DOM 动画效果的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制“ANIME”文字动画
            ctx.font = 'bold 20px Inter';
            ctx.textAlign = 'center';
            const text = 'ANIME';
            const letters = text.split('');
            
            letters.forEach((letter, i) => {
                const x = width / 2 + (i - 2) * 25;
                const y = height / 2 - 20;
                const time = Date.now() * 0.003;
                const wave = Math.sin(time + i * 0.8) * 8;
                
                ctx.fillStyle = `hsl(${240 + i * 20}, 70%, 65%)`;
                ctx.globalAlpha = 0.9;
                ctx.fillText(letter, x, y + wave);
            });
            
            // 绘制浮动的小元素
            const time = Date.now() * 0.002;
            for (let i = 0; i < 8; i++) {
                const angle = time + i * (Math.PI * 2 / 8);
                const radius = 50 + Math.sin(time * 1.5 + i) * 15;
                const x = width / 2 + Math.cos(angle) * radius;
                const y = height / 2 + 20 + Math.sin(angle) * radius;
                const size = 3 + Math.sin(time * 2 + i) * 2;
                
                const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b'];
                ctx.fillStyle = colors[i % colors.length];
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawTrianglesPreview(ctx, width, height) {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.002;
            const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b'];
            
            // 创建固定位置但会变色和大小的三角形
            for (let i = 0; i < 15; i++) {
                const row = Math.floor(i / 5);
                const col = i % 5;
                const x = (col + 0.5) * (width / 5);
                const y = (row + 0.5) * (height / 3);
                const size = 15 + Math.sin(time * 2 + i * 0.5) * 8;
                const colorIndex = Math.floor(time * 0.5 + i * 0.3) % colors.length;
                
                ctx.fillStyle = colors[colorIndex];
                ctx.globalAlpha = 0.6 + Math.sin(time * 1.5 + i) * 0.2;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(time * 0.5 + i * 0.2);
                
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(-size * 0.866, size * 0.5);
                ctx.lineTo(size * 0.866, size * 0.5);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        function drawNetPreview(ctx, width, height) {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            
            // 创建动态移动的粒子
            const particles = [];
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: width/2 + Math.cos(time * 0.5 + i * Math.PI * 0.25) * 60,
                    y: height/2 + Math.sin(time * 0.3 + i * Math.PI * 0.25) * 40,
                    size: 3 + Math.sin(time * 2 + i) * 1
                });
            }
            
            // 绘制连接线
            ctx.strokeStyle = '#6366f1';
            ctx.globalAlpha = 0.3;
            particles.forEach((p1, i) => {
                particles.forEach((p2, j) => {
                    if (i < j) {
                        const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
                        if (dist < 100) {
                            ctx.lineWidth = Math.max(1, 3 - dist / 50);
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                });
            });
            
            // 绘制粒子
            ctx.fillStyle = '#6366f1';
            ctx.globalAlpha = 0.8;
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPhysicsPreview(ctx, width, height) {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.003;
            const shapes = ['#6366f1', '#8b5cf6', '#ec4899'];
            
            // 模拟物理引擎的下落和弹跳效果
            for (let i = 0; i < 6; i++) {
                ctx.fillStyle = shapes[i % shapes.length];
                ctx.globalAlpha = 0.8;
                
                // 创建上下弹跳的效果
                const baseX = (i % 3 + 1) * (width / 4);
                const baseY = height / 2;
                const bounceHeight = Math.abs(Math.sin(time * 2 + i * 0.5)) * 60;
                const x = baseX + Math.sin(time * 0.5 + i) * 20;
                const y = baseY - bounceHeight;
                const size = 15 + Math.sin(time * 3 + i) * 5;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(time + i * 0.3);
                
                if (i % 2 === 0) {
                    // 圆形
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // 矩形
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                }
                
                ctx.restore();
                
                // 绘制影子效果
                ctx.fillStyle = shapes[i % shapes.length];
                ctx.globalAlpha = 0.2;
                const shadowSize = size * (1 + bounceHeight / 60);
                ctx.save();
                ctx.scale(1, 0.3);
                ctx.beginPath();
                ctx.arc(baseX, (height / 2 + 40) / 0.3, shadowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function draw3DPreview(ctx, width, height) {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.002;
            ctx.strokeStyle = '#6366f1';
            ctx.globalAlpha = 0.8;
            
            const centerX = width / 2;
            const centerY = height / 2;
            const size = 40;
            
            // 创建旋转的 3D 立方体
            const rotX = time;
            const rotY = time * 0.7;
            
            // 基础立方体顶点
            const basePoints = [
                [-size, -size, -size], [size, -size, -size], [size, size, -size], [-size, size, -size],
                [-size, -size, size], [size, -size, size], [size, size, size], [-size, size, size]
            ];
            
            // 旋转变换
            const rotatedPoints = basePoints.map(([x, y, z]) => {
                // Y轴旋转
                const x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
                const z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
                
                // X轴旋转
                const y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
                const z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
                
                return [x1, y1, z2];
            });
            
            // 投影到 2D
            const projectedPoints = rotatedPoints.map(([x, y, z]) => [
                centerX + x,
                centerY + y
            ]);
            
            const edges = [
                [0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4],
                [0,4], [1,5], [2,6], [3,7]
            ];
            
            // 绘制边线
            edges.forEach(edge => {
                const start = projectedPoints[edge[0]];
                const end = projectedPoints[edge[1]];
                
                ctx.beginPath();
                ctx.moveTo(start[0], start[1]);
                ctx.lineTo(end[0], end[1]);
                ctx.stroke();
            });
            
            // 绘制顶点
            ctx.fillStyle = '#6366f1';
            projectedPoints.forEach(([x, y]) => {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGenerativePreview(ctx, width, height) {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 创建动态的螺旋和波浪效果
            for (let i = 0; i < 80; i++) {
                const angle = (i / 80) * Math.PI * 4 + time;
                const radius = 20 + i * 1.5 + Math.sin(time * 2 + i * 0.1) * 10;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const size = 2 + Math.sin(time * 3 + i * 0.05) * 1;
                
                ctx.fillStyle = `hsl(${250 + i * 1.5 + time * 20}, 70%, ${60 + Math.sin(time + i * 0.1) * 20}%)`;
                ctx.globalAlpha = 0.7 + Math.sin(time * 1.5 + i * 0.2) * 0.2;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 添加中心的辐射效果
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + time * 0.5;
                const startRadius = 10;
                const endRadius = 100;
                
                const gradient = ctx.createRadialGradient(centerX, centerY, startRadius, centerX, centerY, endRadius);
                gradient.addColorStop(0, `hsla(${270 + i * 5}, 70%, 60%, 0.8)`);
                gradient.addColorStop(1, `hsla(${270 + i * 5}, 70%, 60%, 0)`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3;
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * endRadius,
                    centerY + Math.sin(angle) * endRadius
                );
                ctx.stroke();
            }
        }

        function drawVantaPreview(ctx, width, height) {
            // 创建动态 Vanta 波浪效果的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            ctx.strokeStyle = '#6366f1';
            ctx.globalAlpha = 0.6;
            
            // 绘制动态波浪形状
            const waveHeight = 15;
            const waveLength = 60;
            
            // 多层波浪效果
            for (let layer = 0; layer < 4; layer++) {
                ctx.strokeStyle = `hsl(${220 + layer * 10}, 70%, ${50 + layer * 10}%)`;
                ctx.lineWidth = 2 - layer * 0.3;
                ctx.globalAlpha = 0.8 - layer * 0.15;
                
                for (let y = layer * 30; y < height; y += 120) {
                    ctx.beginPath();
                    for (let x = 0; x <= width; x += 3) {
                        const waveY = y + Math.sin((x / waveLength + time * (1 + layer * 0.5)) * Math.PI * 2) * waveHeight * (1 - layer * 0.2);
                        if (x === 0) {
                            ctx.moveTo(x, waveY);
                        } else {
                            ctx.lineTo(x, waveY);
                        }
                    }
                    ctx.stroke();
                }
            }
            
            // 添加浮动的光点
            for (let i = 0; i < 8; i++) {
                const x = (i * width / 8) + Math.sin(time * 0.5 + i) * 30;
                const y = height / 2 + Math.cos(time * 0.3 + i) * 40;
                const size = 2 + Math.sin(time * 2 + i) * 1;
                
                ctx.fillStyle = '#6366f1';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawParticlesJSPreview(ctx, width, height) {
            // 创建动态 Particles.js 效果的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.0005;
            ctx.strokeStyle = '#6366f1';
            ctx.fillStyle = '#6366f1';
            
            // 创建动态粒子
            const particles = [];
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: width/2 + Math.cos(time * (0.5 + i * 0.1) + i) * (30 + i * 8),
                    y: height/2 + Math.sin(time * (0.3 + i * 0.05) + i * 0.5) * (20 + i * 6),
                    size: 2 + Math.sin(time * 3 + i) * 1
                });
            }
            
            // 绘制动态连线
            ctx.globalAlpha = 0.3;
            particles.forEach((p1, i) => {
                particles.forEach((p2, j) => {
                    if (i < j) {
                        const dist = Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
                        if (dist < 80) {
                            ctx.lineWidth = Math.max(0.5, 2 - dist / 60);
                            ctx.globalAlpha = Math.max(0.1, 0.5 - dist / 160);
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                        }
                    }
                });
            });
            
            // 绘制动态粒子
            ctx.globalAlpha = 0.9;
            particles.forEach((p, i) => {
                const pulseSize = p.size + Math.sin(time * 4 + i * 0.5) * 0.5;
                ctx.fillStyle = `hsl(${220 + Math.sin(time + i) * 20}, 70%, 60%)`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 添加微弱的光晕
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, pulseSize * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 0.9;
            });
        }

        function drawGSAPPreview(ctx, width, height) {
            // 创建 GSAP 专业动画效果的预览
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.002;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 绘制 "GSAP" 文字动画效果
            ctx.font = 'bold 24px Inter';
            ctx.textAlign = 'center';
            const text = 'GSAP';
            const letters = text.split('');
            
            letters.forEach((letter, i) => {
                const x = centerX + (i - 1.5) * 25;
                const y = centerY - 30;
                const bounce = Math.sin(time * 3 + i * 0.8) * 5;
                const scale = 1 + Math.sin(time * 2 + i * 0.5) * 0.1;
                
                ctx.save();
                ctx.translate(x, y + bounce);
                ctx.scale(scale, scale);
                
                // 渐变色文字
                const gradient = ctx.createLinearGradient(-15, -15, 15, 15);
                gradient.addColorStop(0, `hsl(${240 + i * 30}, 80%, 70%)`);
                gradient.addColorStop(1, `hsl(${270 + i * 30}, 80%, 60%)`);
                ctx.fillStyle = gradient;
                ctx.globalAlpha = 0.9;
                ctx.fillText(letter, 0, 0);
                
                ctx.restore();
            });
            
            // 绘制时间轴动画指示器
            const timelineY = centerY + 20;
            const timelineWidth = 120;
            const timelineX = centerX - timelineWidth / 2;
            
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.moveTo(timelineX, timelineY);
            ctx.lineTo(timelineX + timelineWidth, timelineY);
            ctx.stroke();
            
            // 动态进度指示器
            const progress = (Math.sin(time * 2) + 1) / 2;
            const progressX = timelineX + progress * timelineWidth;
            
            ctx.fillStyle = '#ff6b6b';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(progressX, timelineY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制旋转的几何元素
            for (let i = 0; i < 4; i++) {
                const angle = time + i * Math.PI / 2;
                const radius = 50;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const size = 8 + Math.sin(time * 3 + i) * 3;
                const rotation = time * 2 + i;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                
                const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b'];
                ctx.fillStyle = colors[i];
                ctx.globalAlpha = 0.7;
                
                if (i % 2 === 0) {
                    // 矩形
                    ctx.fillRect(-size, -size, size * 2, size * 2);
                } else {
                    // 圆形
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            // 绘制路径动画轨迹
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.4;
            ctx.beginPath();
            
            for (let t = 0; t <= 1; t += 0.02) {
                const angle = t * Math.PI * 4 + time * 0.5;
                const r = 30 + t * 20;
                const x = centerX + Math.cos(angle) * r;
                const y = centerY + 50 + Math.sin(angle) * r;
                
                if (t === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }

        // 为动态预览添加动画循环
        function animatePreviews() {
            // Anime.js 动画
            const animeCanvas = document.getElementById('anime-preview');
            if (animeCanvas) {
                const ctx = animeCanvas.getContext('2d');
                drawAnimePreview(ctx, animeCanvas.width, animeCanvas.height);
            }
            
            // Canvas Confetti 动画
            const confettiCanvas = document.getElementById('confetti-preview');
            if (confettiCanvas) {
                const ctx = confettiCanvas.getContext('2d');
                drawConfettiPreview(ctx, confettiCanvas.width, confettiCanvas.height);
            }
            
            // Rough.js 动画
            const roughCanvas = document.getElementById('rough-preview');
            if (roughCanvas) {
                const ctx = roughCanvas.getContext('2d');
                drawRoughPreview(ctx, roughCanvas.width, roughCanvas.height);
            }
            
            // Trianglify 动画
            const trianglifyCanvas = document.getElementById('trianglify-preview');
            if (trianglifyCanvas) {
                const ctx = trianglifyCanvas.getContext('2d');
                drawTrianglesPreview(ctx, trianglifyCanvas.width, trianglifyCanvas.height);
            }
            
            // Canvas Nest 动画
            const canvasNestCanvas = document.getElementById('canvas-nest-preview');
            if (canvasNestCanvas) {
                const ctx = canvasNestCanvas.getContext('2d');
                drawNetPreview(ctx, canvasNestCanvas.width, canvasNestCanvas.height);
            }
            
            // Matter.js 动画
            const matterCanvas = document.getElementById('matter-preview');
            if (matterCanvas) {
                const ctx = matterCanvas.getContext('2d');
                drawPhysicsPreview(ctx, matterCanvas.width, matterCanvas.height);
            }
            
            // Three.js 动画
            const threeCanvas = document.getElementById('three-preview');
            if (threeCanvas) {
                const ctx = threeCanvas.getContext('2d');
                draw3DPreview(ctx, threeCanvas.width, threeCanvas.height);
            }
            
            // P5.js 动画
            const p5Canvas = document.getElementById('p5-preview');
            if (p5Canvas) {
                const ctx = p5Canvas.getContext('2d');
                drawGenerativePreview(ctx, p5Canvas.width, p5Canvas.height);
            }
            
            // Vanta.js 动画
            const vantaCanvas = document.getElementById('vanta-preview');
            if (vantaCanvas) {
                const ctx = vantaCanvas.getContext('2d');
                drawVantaPreview(ctx, vantaCanvas.width, vantaCanvas.height);
            }
            
            // Particles.js 动画
            const particlesCanvas = document.getElementById('particles-preview');
            if (particlesCanvas) {
                const ctx = particlesCanvas.getContext('2d');
                drawParticlesJSPreview(ctx, particlesCanvas.width, particlesCanvas.height);
            }

            // GSAP 动画
            const gsapCanvas = document.getElementById('gsap-preview');
            if (gsapCanvas) {
                const ctx = gsapCanvas.getContext('2d');
                drawGSAPPreview(ctx, gsapCanvas.width, gsapCanvas.height);
            }
            
            requestAnimationFrame(animatePreviews);
        }
        
        // 启动预览动画
        setTimeout(() => {
            animatePreviews();
        }, 1000);

        // 窗口大小改变时重新绘制预览
        window.addEventListener('resize', () => {
            setTimeout(initPreviews, 100);
        });
    </script>
</body>
</html>
